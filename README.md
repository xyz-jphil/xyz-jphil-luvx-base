# LuvX: Universal DSL Foundation for Any Language

**A universal foundation for building type-safe DSLs in Java - HTML/XML/XHTML/SVG, CSS, JSON, perhaps React DOM, and beyond**

[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://openjdk.java.net/projects/jdk/21/)
[![Maven](https://img.shields.io/badge/Maven-3.8+-blue.svg)](https://maven.apache.org/)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)
[![Version](https://img.shields.io/badge/Version-2.0-blue.svg)]()

## What is LuvX?

LuvX is a universal DSL foundation where **X can be anything** - HTML, XML, SVG, CSS, JSON, (perhaps React DOM), or any structured language you can imagine. It provides the type-safe building blocks for creating beautiful, composable DSLs.

**LuvML** is the flagship implementation of LuvX, specifically targeting HTML/XML with complete grammar support.

The "X" represents infinite possibilities:
- **HTML/XML** (LuvML) - Complete markup with attributes, elements, text nodes, comments
- **CSS** - Style declarations (attributes only, no text nodes/comments) 
- **JSON** - Object structures (simplified grammar)
- **React DOM** - Component trees (theoretical)
- **Custom DSLs** - Maven POMs, configuration files, or any structured format

## Quick Examples

### HTML/XML (LuvX/LuvML)
```java
// Rich HTML with full XML grammar features
var document = html(
    head(title("My App"), meta(charset("UTF-8"))),
    body(
        h1("Welcome to LuvX/LuvML"), 
        p("Build ", styledText("type-safe markup", "font-weight: bold")),
        // XML features: comments, text nodes, attributes all supported
        comment("Generated by LuvX/LuvML"),
        button(onClick("alert('Hello!')"), "Click Me")
    )
);
```

### CSS (LuvX/CSS - Theoretical)
```java
// Simplified grammar - attributes only, no text nodes or comments
var styles = stylesheet(
    rule(".container",
        display__flex(),
        justify_content__center()
    ),
    rule(h1(), 
        color("blue"),
        font_size(px(24))
    )
);
```

### JSON (LuvX/JSON - Theoretical)
```java
// Even simpler grammar - object/array structures
var config = jsonObject(
    name("MyApp"),
    version(2.0),
    dependencies("react", "lodash") //array type
);
```

## Core Concept: Frag_I - The Universal Fragment

**Credit**: The `Frag` concept originates from **ScalaTags** by Li Haoyi. We independently discovered the same pattern in LuvML 1.0, calling it `___F` (as in "Flow"). LuvX 2.0 adopts the `Frag_I` naming for consistency while adding Java 21 sealed types and discriminated unions - making it more Scala-like thanks to influence from the Scala ecosystem.

Everything in any structured language is a **fragment** (`Frag_I`):

```java
public interface Frag_I<I extends Frag_I<I>> {
    FragType_I<I> fragType(); // Union type discrimination
}
```

This creates a flexible hierarchy that adapts to any grammar:

```
Frag_I<I>                    // Root: any structured piece
├── Attr_I<I>               // Key-value pairs: id="main", color="red"
├── Node_I<I>               // Content nodes
│   ├── AttributelessNode_I<I>  // Simple content
│   │   ├── Text_I<I>           // Text content
│   │   ├── Comment_I<I>        // <!-- comments --> (HTML/XML only)
│   │   └── Doctype_I<I>        // <!DOCTYPE> (HTML/XML only)
│   └── Element_I<I>            // Structured elements
│       ├── SelfClosingElement_I<I>  // <br/>, single values
│       └── ContainerElement_I<I>    // <div>...</div>, objects/arrays
└── Frags_I<I>              // Collections of fragments
```

**Language Adaptation**: 
- **HTML/XML** uses the full hierarchy (attributes, text, comments, elements)
- **CSS** primarily uses attributes (properties) and container elements (rules)
- **JSON** uses container elements (objects/arrays) and simple values
- **Custom DSLs** pick and choose what they need

## LuvX vs LuvX/LuvML Usage

### LuvX (Core Foundation)
When discussing the universal DSL foundation:
```java
// LuvX provides the interfaces
interface Element_I<I extends Element_I<I>> extends Frag_I<I> {
    String tagName();
    List<Attr_I<?>> attributes();
}
```

### LuvX/LuvML (HTML/XML Implementation)
When showing specific HTML/XML usage:
```java
// LuvX/LuvML provides the concrete HTML implementation
var webpage = html(  // LuvX/LuvML DSL functions
    head(title("My Blog")),
    body(h1("Content"))
);
```

## Real-World Usage Examples

### 1. Complete HTML Page (LuvX/LuvML)

```java
import static luvx.E.*;
import static luvx.A.*;

var webpage = html(
    head(
        title("My Blog"),
        meta(charset("UTF-8")),
        style("body { font-family: Arial; }")
    ),
    body(
        header(
            h1("Welcome to My Blog"),
            nav(a(href("/"), "Home"), a(href("/about"), "About"))
        ),
        main(
            article(
                h2("First Post"),
                p("This is my ", styledText("first blog post", "font-weight: bold")),
                comment("This comment is preserved in the DOM"),
                p("Written using LuvX/LuvML DSL!")
            )
        )
    )
);
```

### 2. SVG Graphics (LuvX/SVG)

```java
var logo = svg(
    xmlns("http://www.w3.org/2000/svg"),
    viewBox(0, 0, 100, 100),
    circle(cx(50), cy(50), r(40), fill("blue")),
    text(x(50), y(55), textAnchor__middle(), fill(white), "LuvX") // notice white as static variable
);
```

## A few technical unique aspects

### 1. Algebraic Data Types in Java

LuvX achieves algebraic data types using method-based discrimination and java 21 sealed classes:

```java
// This creates: FragType_I with multiple variants (not just 2!)
// FragType_I = Attr_T | Node_T | Frags_T | ... (extensible)
switch (fragment.fragType()) {
    case Attr_T a -> handleAttribute(a.attr());
    case Node_T n -> handleNode(n.node());
    case Frags_T f -> handleFragments(f.frags());
}
```

### 2. Zero-Cast Type Safety

No casting needed - types are preserved through the hierarchy:

```java
String processFragment(Frag_I<?> frag) {
    return switch (frag.fragType()) {
        case Attr_T a -> {
            var attr = a.attr(); // Type: Attr_I - NO CASTING!
            yield "Attribute: " + attr.name() + "=" + attr.value();
        }
        case Node_T n -> switch (n.nodeType()) {
            case Element_T e -> {
                var element = e.element(); // Type: Element_I - NO CASTING!
                yield "Element: <" + element.tagName() + ">";
            }
            case AttributelessNode_T an -> switch (an.attributelessNodeType()) {
                case Text_T t -> {
                    var text = t.text(); // Type: Text_I - NO CASTING!
                    yield "Text: " + text.textContent();
                }
                case Comment_T c -> {
                    var comment = c.comment(); // Type: Comment_I - NO CASTING!
                    yield "Comment: " + comment.comment();
                }
                // More cases as needed...
            };
        };
        case Frags_T f -> {
            var frags = f.frags(); // Type: Frags_I - NO CASTING!
            yield "Collection: " + frags.fragments().size() + " items";
        }
        // Pattern can extend to any number of alternatives
    };
}
```

### 3. Grammar Flexibility

The same DSL foundation adapts to different language requirements:

```java
// HTML/XML - Full grammar support
var htmlDoc = html(comment("Full featured"), body(text("content")));

// CSS - Attributes and rules only  
var cssDoc = stylesheet(rule(".class", color("red")));

// JSON - Objects and simple values
var jsonDoc = object(name("MyApp"), version(2.0));
```

## Comparison with Other Approaches

**Note**: Comparing LuvX with JSX is somewhat apples-to-oranges since JSX is primarily a client-side template syntax while LuvX is a universal DSL foundation. However, for HTML generation:

| Approach | Type Safety | Syntax | Performance | IDE Support | Target |
|----------|-------------|---------|-------------|-------------|---------|
| **String concatenation** | ❌ None | ❌ Messy | ✅ Fast | ❌ No validation | Any |
| **Template engines** | ⚠️ Limited | ✅ Good | ⚠️ Moderate | ⚠️ Limited | Server |
| **JSX (React)** | ✅ Good | ✅ Excellent | ✅ Good | ✅ Excellent | Client |
| **LuvX DSL** | ✅ Excellent | ✅ Excellent | ✅ Good | ✅ Full Java support | Universal |

**Client-Side Note**: LuvX can theoretically be used client-side (with teavm), but current development focuses on server-side rendering (SSR). This is not due to design limitations but rather current actual development needs.

## Getting Started

### Prerequisites

- Java 21+ (for sealed interfaces and pattern matching)
- Maven 3.8+

### Installation

```xml
<dependency>
    <groupId>io.github.xyz-jphil</groupId>
    <artifactId>xyz-jphil-luvx-base</artifactId>
    <version>2.0</version>
</dependency>
```

### Basic Usage

1. **Import static methods** for clean syntax:
```java
import static luvx.E.*;
import static luvx.A.*;
```

2. **Build your structures** using method calls:
```java
var page = html(
    head(title("My App")),
    body(h1("Hello World"))
);
```

3. **Process or render** your structure:
```java
// Type-safe processing preserving the DOM
String result = processFragment(page);
```

### Run the Examples
Some examples (possibly outdated) are packaged separately in 
https://github.com/xyz-jphil/xyz-jphil-luvx-examples.git


## Why LuvX/LuvML?

### Comparison with HTMLFlow

LuvML version 1.x was inspired by **HTMLFlow** but designed with different goals.
LuvX/LuvML version 2.0 takes inspiration from ScalaTags (mainly in form of reassurance of the concept as such) and adds more of it's own unique aspects:

| Aspect | HTMLFlow | LuvX/LuvML |
|--------|----------|------------|
| **Purpose** | Academic SSR performance | Universal DSL foundation |
| **Output** | String/Stream only | DOM tree + multiple formats |
| **Grammar** | Strict HTML5 | Flexible, custom elements/attributes allowed |
| **Extensibility** | Complex to extend | Easy to add DSL functions |
| **Target** | Server-side only | Universal (SSR + client-side ready) |
| **DOM** | Not preserved | Mutable DOM tree is primary output |
| **Client Support** | None | Originally JSweet, now hopefully TeaVm |

**Key Differences**:
- **HTMLFlow** maximizes SSR performance and minimizes memory usage
- **LuvX/LuvML** preserves DOM trees for manipulation - the DOM itself is often the desired output
- **HTMLFlow** converts everything to strings/streams immediately  
- **LuvX/LuvML** keeps structured data for multiple use cases (inspection, modification, different serialization formats)

### Historical Evolution

- **LuvML 1.0** - Originally compatible with JSWeet for client-side execution
- **LuvX/LuvML 2.0** - Drops JSWeet but keeps client-side possibilities open  
- **Future Vision** - Originally imagined for Maven POMs, Lombok-style builders with named parameters as static function DSLs, but HTML/XML proved most valuable

### Original Broader Vision

At creation time, it was imagined that LuvX could be used to:
- **Maven POMs** - `pom(groupId("com.example"), artifactId("my-app"), dependencies(...))` but as of I see just maintain simple pom.xml or move to gradle or mill (which is said to be faster)
- **Lombok-style builders** - Replace annotation-based builders with DSL-style named parameter functions, but not pursued because lombok fluent builders are simpler and more strict.
- **Configuration files** - Any structured data format, haven't ventured into that yet, mostly using lombok and jaxb or Gson (depending upon format of saving data) and other custom annotations similar to lombok.

While these didn't feel as immediately useful as HTML/XML, the pattern remains interesting and the "X" keeps the door open for such implementations.

### Why Choose LuvX/LuvML?

Traditional HTML generation in Java is painful:

```java
// ❌ String hell
StringBuilder html = new StringBuilder();
html.append("<div class=\"").append(className).append("\">");
html.append("<h1>").append(escapeHtml(title)).append("</h1>");
```

LuvX/LuvML gives you:
- **Compile-time validation** - typos caught at build time
- **Full IDE support** - autocomplete, refactoring, navigation - if you define a custom html5 attribute/element and later decide to rename/refactor it, the changes reflect throughout because it is not a string but a function;
- **Type safety** - no runtime errors
- **Clean syntax** - reads like the structure you want, much easier to visualize the html/xml you are creating.
- **Composable** - break complex documents into reusable functions
- **DOM preservation** - manipulate structures after creation (not the focus of htmlflow)
- **Multiple outputs** - same code, different serialization formats (the rendering logic is completely separated from the dom tree creation - even in ScalaTags the string rendering pipeline is a focus, for us it is an adapter)

## Universal DSL Vision

LuvX demonstrates that the same foundation can power completely different languages:

### Implemented
- **LuvX/LuvML** - Complete HTML/XML with comments, doctypes, processing instructions

### Theoretical Applications  
- **LuvX/CSS** - Style declarations using attributes and container rules
- **LuvX/JSON** - Object structures with simplified grammar
- **LuvX/React** - Component trees for JSX-like syntax in Java
- **LuvX/Config** - Configuration files, Maven POMs, YAML-like structures

The pattern is universal: any structured language can be expressed through the Frag_I hierarchy.

## Contributing

We welcome contributions! Areas where you can help:

- **New DSL implementations** (CSS, JSON, YAML, etc.)
- **Client-side execution** support
- **Performance optimizations**  
- **Multiple render targets**
- **Documentation improvements**

## License

There is NO license specified for this project and sub-projects to reduce source code file size;
Much is generated using AI and previous version code reference etc.
So author is not interested in applying any license and permits all kinds of use. 
For the sake for formality you may assume this is licensed under the Apache License version 2.0

---

**LuvX**: The universal foundation for type-safe DSLs in Java.  
**LuvX/LuvML**: Beautiful, type-safe HTML/XML generation.

*Build any structured language the way it should be - with compile-time safety and clean syntax.*